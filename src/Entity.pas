unit Entity;

interface

uses
  SysUtils, StrUtils, Generics.Collections, System.TypInfo, Rtti,
  ZAbstractConnection, Data.DB;

type
  EntityAttribute = class(TCustomAttribute)
  private
    FTableName : string;
    FSchemaName : string;
    function GetFullName: string;
  public
    constructor Create(const ATableName: string; const ASchemaName: string = '');

    property TableName: string read FTableName;
    property Schema: string read FSchemaName;
    property FullName: string read GetFullName;
  end;

  TColProp = (
    cpPrimaryKey,
    cpUnique,
    cpNotNull,
    cpAutoGenerated
  );

  TColProps = set of TColProp;

  ColumnAttribute = class(TCustomAttribute)
  private
    FColumnName : string;
    FLength: Integer;
    FPrecision: Integer;
    FScale: Integer;
    FColProps : TColProps;
    function GetIsPrimaryKey: Boolean;
    function GetIsAutoGenerated: Boolean;
  public
    constructor Create(const AColumnName : string) overload;
    constructor Create(const AColumnName : string; AColProps : TColProps;
                       ALength : Integer=0;
                       APrecision : Integer=0;
                       AScale : Integer=0); overload;
    constructor Create(AColProps : TColProps;
                       ALength : Integer=0;
                       APrecision : Integer=0;
                       AScale : Integer=0); overload;

    property ColumnName: string read FColumnName write FColumnName;
    property Length: Integer read FLength write FLength;
    property Precision: Integer read FPrecision write FPrecision;
    property Scale: Integer read FScale write FScale;
    property ColProps: TColProps read FColProps write FColProps;
    property IsPrimaryKey: Boolean read GetIsPrimaryKey;
    property IsAutoGenerated: Boolean read GetIsAutoGenerated;
  end;

  NotMapped = class(TCustomAttribute)
  end;

  OneToOne = class(TCustomAttribute)
  private
    FFilterPropertyName : string;
    FValuePropertyName : string;
  public
    constructor Create(const AFilterPropertyName: string; const AValuePropertyName: string);
    property FilterPropertyName: string read FFilterPropertyName write FFilterPropertyName;
    property ValuePropertyName: string read FValuePropertyName write FValuePropertyName;
  end;

  OneToMany = class(TCustomAttribute)
  private
    FFilterPropertyName : string;
    FValuePropertyName : string;
  public
    constructor Create(const AFilterPropertyName: string; const AValuePropertyName: string);
    property FilterPropertyName: string read FFilterPropertyName write FFilterPropertyName;
    property ValuePropertyName: string read FValuePropertyName write FValuePropertyName;
  end;

  TEntity = class
  private
    FID: Int64;
  public
    constructor Create; virtual;

    [ColumnAttribute('id', [cpPrimaryKey, cpUnique, cpNotNull, cpAutoGenerated])]
    property ID: Int64 read FID write FID;

    function GetTableName(AWithSchema: Boolean = False): string;

    function GetQuery(AID: Int64; AWithSchema: Boolean = False): string;
    function AddQuery(AWithSchema: Boolean = False): string;
    function UpdateQuery(AWithSchema: Boolean = False): string;
    function DeleteQuery(AID: Int64; AWithSchema: Boolean = False): string;
    function DeleteBatchQuery(AFilter: string; AWithSchema: Boolean = False): string;

    procedure SetValuesFromDbFields(AFields: TFields);
    procedure Clear;
    function Clone<T>: T;
  end;

implementation

uses
  System.Classes;

constructor EntityAttribute.Create(const ATableName, ASchemaName: string);
begin
  inherited Create;
  FTableName := ATableName;
  FSchemaName := ASchemaName;
end;

function EntityAttribute.GetFullName: string;
begin
  Result := IfThen(FSchemaName='', FTableName, FSchemaName + '.' + FTableName);
end;

constructor ColumnAttribute.Create(const AColumnName: string);
begin
  Create(AColumnName, []);
end;

constructor ColumnAttribute.Create(const AColumnName: string; AColProps: TColProps; ALength, APrecision, AScale: Integer);
begin
  inherited Create;
  FColumnName := AColumnName;
  FColProps := AColProps;
  FLength := ALength;
  FPrecision := APrecision;
  FScale := AScale;
end;

constructor ColumnAttribute.Create(AColProps: TColProps; ALength, APrecision, AScale: Integer);
begin
  inherited Create;
  FColumnName := '';
  FColProps := AColProps;
  FLength := ALength;
  FPrecision := APrecision;
  FScale := AScale;
end;

function ColumnAttribute.GetIsAutoGenerated: Boolean;
begin
  Result := cpAutoGenerated in FColProps;
end;

function ColumnAttribute.GetIsPrimaryKey: Boolean;
begin
  Result := cpPrimaryKey in FColProps;
end;

procedure TEntity.Clear;
var
  ACtx: TRttiContext;
  AType: TRttiType;
  AProp : TRttiProperty;
begin
  ACtx := TRttiContext.Create;
  try
    AType := ACtx.GetType(Self.ClassType);
    for AProp in AType.GetProperties do
    begin
      if AProp.Visibility in [mvPublished, mvPublic] then
      begin
        case AProp.PropertyType.TypeKind of
          tkUnknown       : ;
          tkInteger       : AProp.SetValue(Self, TValue.From(0));
          tkChar          : AProp.SetValue(Self, TValue.From(''));
          tkEnumeration   : AProp.SetValue(Self, TValue.From(0));
          tkFloat         : AProp.SetValue(Self, TValue.From(0));
          tkString        : AProp.SetValue(Self, TValue.From(''));
          tkSet           : ;
          tkClass         : ;
          tkMethod        : ;
          tkWChar         : AProp.SetValue(Self, TValue.From(''));
          tkLString       : AProp.SetValue(Self, TValue.From(''));
          tkWString       : AProp.SetValue(Self, TValue.From(''));
          tkVariant       : ;
          tkArray         : ;
          tkRecord        : ;
          tkInterface     : ;
          tkInt64         : AProp.SetValue(Self, TValue.From(0));
          tkDynArray      : AProp.SetValue(Self, TValue.FromArray(AProp.PropertyType.Handle, []));
          tkUString       : AProp.SetValue(Self, TValue.From(''));
          tkClassRef      : ;
          tkPointer       : AProp.SetValue(Self, TValue.From(nil));
          tkProcedure     : ;
          tkMRecord       : ;
        end;
      end;
    end;
  finally
    ACtx.Free;
  end;
end;

function TEntity.Clone<T>: T;
var
  ACtx: TRttiContext;
  AType: TRttiType;
  AProp : TRttiProperty;
  AMethod: TRttiMethod;
  SourceAsPointer, ResultAsPointer: Pointer;
begin
  ACtx := TRttiContext.Create;
  try
    try
      AType := ACtx.GetType(TypeInfo(T));
      for AMethod in AType.GetMethods do
      begin
        if Assigned(AMethod) and AMethod.IsConstructor and AType.IsInstance then
        begin
          Result := AMethod.Invoke(AType.AsInstance.MetaclassType, []).AsType<T>;
          break;
        end;
      end;

      Move(Self, SourceAsPointer, SizeOf(Pointer));
      Move(Result, ResultAsPointer, SizeOf(Pointer));

      for AProp in AType.GetProperties do
        if  (AProp.Visibility in [mvPublished, mvPublic])
        and AProp.IsReadable
        and AProp.IsWritable
        then
          AProp.SetValue(ResultAsPointer, AProp.GetValue(SourceAsPointer));
    except
      FreeAndNil(Result);
    end;
  finally
    ACtx.Free;
  end;
end;

constructor TEntity.Create;
begin
  inherited;
  //
end;

function TEntity.GetTableName(AWithSchema: Boolean): string;
var
  rCtx: TRttiContext;
  rType: TRttiType;
  LAttr : TCustomAttribute;
begin
  rCtx := TRttiContext.Create;
  try
    rType := rCtx.GetType(Self.ClassType);
    for LAttr in rType.GetAttributes do
      if LAttr is EntityAttribute then
      begin
        if AWithSchema then
          Result := (LAttr as EntityAttribute).GetFullName
        else
          Result := (LAttr as EntityAttribute).TableName;
        Break;
      end;
  finally
    rCtx.Free;
  end;
end;

function TEntity.GetQuery(AID: Int64; AWithSchema: Boolean): string;
var
  ACtx: TRttiContext;
  AType: TRttiType;
  AProp : TRttiProperty;
  LAttr : TCustomAttribute;

  LColName : string;
  LTableName : string;
  LColNames: string;
  LColID: string;
begin
  ACtx := TRttiContext.Create;
  try
    AType := ACtx.GetType(Self.ClassType);
    LTableName := Self.GetTableName(AWithSchema);

    LColNames := '';
    for AProp in AType.GetProperties do
    begin
      if AProp.Visibility in [mvPublished, mvPublic] then
      begin
        for LAttr in AProp.GetAttributes do
        begin
          if LAttr is ColumnAttribute then
          begin
            LColName := ColumnAttribute(LAttr).ColumnName;
            if LColName = '' then
              raise Exception.Create('ColumnAttribute tanýmlý deðil. Bu bilgi tanýmlanmak zorunda.' + sLineBreak +
                                     'Eðer kullanýlmayacaksa "NotMapped" attribute olmak zorunda!!!');
            if LColName = 'id' then
              LColID := LColName
            else
              LColNames := LColNames + LColName + ',';
          end;
        end;
      end;
    end;

    if LColNames = '' then
      raise Exception.Create('SQL sorugusu için field_name bilgilerine ulaþýlamadý!!!');

    LColNames := LColID + ',' + LColNames;

    Result := Trim('SELECT ' + LeftStr(LColNames, Length(LColNames)-1) + ' FROM ' + LTableName + ' WHERE ' + LeftStr(LColNames, 2) + '=' + IntToStr(AID));
  finally
    ACtx.Free;
  end;
end;

function TEntity.AddQuery(AWithSchema: Boolean): string;
var
  ACtx: TRttiContext;
  AType: TRttiType;
  AProp : TRttiProperty;
  LAttr : TCustomAttribute;

  LColName : string;
  LTableName : string;
  LColNames: string;
  LColValues: string;
begin
  ACtx := TRttiContext.Create;
  try
    AType := ACtx.GetType(Self.ClassType);
    LTableName := Self.GetTableName(AWithSchema);

    LColNames := '';
    LColValues := '';
    for AProp in AType.GetProperties do
    begin
      if AProp.Visibility in [mvPublished, mvPublic] then
      begin
        for LAttr in AProp.GetAttributes do
        begin
          if LAttr is ColumnAttribute then
          begin
            LColName := ColumnAttribute(LAttr).ColumnName;

            if LColName = '' then
              raise Exception.Create('ColumnAttribute tanýmlý deðil. Bu bilgi tanýmlanmak zorunda!!!');

            if LColName = 'id' then
              Break;

            LColNames := LColNames + LColName + ',';

            case AProp.PropertyType.TypeKind of
              tkUnknown       : ;
              tkInteger       : LColValues := LColValues + IntToStr(AProp.GetValue(Self).AsInteger) + ',';
              tkChar          : LColValues := LColValues + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkEnumeration   : raise Exception.Create('Tanýmlý olmayan data type');
              tkFloat         : LColValues := LColValues + FloatToStr(AProp.GetValue(Self).AsExtended) + ',';
              tkString        : LColValues := LColValues + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkSet           : raise Exception.Create('Tanýmlý olmayan data type');
              tkClass         : raise Exception.Create('Tanýmlý olmayan data type');
              tkMethod        : raise Exception.Create('Tanýmlý olmayan data type');
              tkWChar         : LColValues := LColValues + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkLString       : LColValues := LColValues + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkWString       : LColValues := LColValues + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkVariant       : raise Exception.Create('Tanýmlý olmayan data type');
              tkArray         : raise Exception.Create('Tanýmlý olmayan data type');
              tkRecord        : raise Exception.Create('Tanýmlý olmayan data type');
              tkInterface     : raise Exception.Create('Tanýmlý olmayan data type');
              tkInt64         : LColValues := LColValues + IntToStr(AProp.GetValue(Self).AsInt64) + ',';
              tkDynArray      : raise Exception.Create('Tanýmlý olmayan data type');
              tkUString       : LColValues := LColValues + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkClassRef      : raise Exception.Create('Tanýmlý olmayan data type');
              tkPointer       : raise Exception.Create('Tanýmlý olmayan data type');
              tkProcedure     : raise Exception.Create('Tanýmlý olmayan data type');
              tkMRecord       : raise Exception.Create('Tanýmlý olmayan data type');
            end;
          end;
        end;
      end;
    end;

    Result := trim('INSERT INTO ' + LTableName + '(' + LeftStr(LColNames, Length(LColNames)-1) +
                                        ') VALUES (' + LeftStr(LColValues, Length(LColValues)-1) + ') RETURNING id;');
  finally
    ACtx.Free;
  end;
end;

function TEntity.UpdateQuery(AWithSchema: Boolean): string;
var
  ACtx: TRttiContext;
  AType: TRttiType;
  AProp : TRttiProperty;
  LAttr : TCustomAttribute;

  LColName : string;
  LTableName : string;
  LColNames: string;
begin
  ACtx := TRttiContext.Create;
  try
    AType := ACtx.GetType(Self.ClassType);
    LTableName := Self.GetTableName(AWithSchema);

    LColNames := '';
    for AProp in AType.GetProperties do
    begin
      if AProp.Visibility in [mvPublished, mvPublic] then
      begin
        for LAttr in AProp.GetAttributes do
        begin
          if LAttr is ColumnAttribute then
          begin
            LColName := ColumnAttribute(LAttr).ColumnName;

            if LColName = '' then
              raise Exception.Create('ColumnAttribute tanýmlý deðil. Bu bilgi tanýmlanmak zorunda!!!');

            if LColName = 'id' then
              Break;

            case AProp.PropertyType.TypeKind of
              tkUnknown       : ;
              tkInteger       : LColNames := LColNames + LColName + '=' + IntToStr(AProp.GetValue(Self).AsInteger) + ',';
              tkChar          : LColNames := LColNames + LColName + '=' + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkEnumeration   : raise Exception.Create('Tanýmlý olmayan data type');
              tkFloat         : LColNames := LColNames + LColName + '=' + FloatToStr(AProp.GetValue(Self).AsExtended) + ',';
              tkString        : LColNames := LColNames + LColName + '=' + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkSet           : raise Exception.Create('Tanýmlý olmayan data type');
              tkClass         : raise Exception.Create('Tanýmlý olmayan data type');
              tkMethod        : raise Exception.Create('Tanýmlý olmayan data type');
              tkWChar         : LColNames := LColNames + LColName + '=' + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkLString       : LColNames := LColNames + LColName + '=' + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkWString       : LColNames := LColNames + LColName + '=' + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkVariant       : raise Exception.Create('Tanýmlý olmayan data type');
              tkArray         : raise Exception.Create('Tanýmlý olmayan data type');
              tkRecord        : raise Exception.Create('Tanýmlý olmayan data type');
              tkInterface     : raise Exception.Create('Tanýmlý olmayan data type');
              tkInt64         : LColNames := LColNames + IntToStr(AProp.GetValue(Self).AsInt64) + ',';
              tkDynArray      : raise Exception.Create('Tanýmlý olmayan data type');
              tkUString       : LColNames := LColNames + LColName + '=' + QuotedStr(AProp.GetValue(Self).AsString) + ',';
              tkClassRef      : raise Exception.Create('Tanýmlý olmayan data type');
              tkPointer       : raise Exception.Create('Tanýmlý olmayan data type');
              tkProcedure     : raise Exception.Create('Tanýmlý olmayan data type');
              tkMRecord       : raise Exception.Create('Tanýmlý olmayan data type');
            end;
          end;
        end;
      end;
    end;

    Result := Trim('UPDATE ' + LTableName + ' SET ' + LeftStr(LColNames, Length(LColNames)-1) + ' WHERE id=' + IntToStr(Self.ID));
  finally
    ACtx.Free;
  end;
end;

function TEntity.DeleteQuery(AID: Int64; AWithSchema: Boolean): string;
var
  LTableName : string;
begin
  LTableName := Self.GetTableName(AWithSchema);
  Result := Trim('DELETE FROM ' + LTableName + ' WHERE id=' + IntToStr(AID));
end;

function TEntity.DeleteBatchQuery(AFilter: string; AWithSchema: Boolean): string;
var
  LTableName : string;
begin
  LTableName := Self.GetTableName(AWithSchema);
  Result := Trim('DELETE FROM ' + LTableName + ' WHERE 1=1 ' + Trim(AFilter));
end;

procedure TEntity.SetValuesFromDbFields(AFields: TFields);
var
  ACtx: TRttiContext;
  AType: TRttiType;
  AProp : TRttiProperty;
  AAttr : TCustomAttribute;

  n1: Integer;
begin
  if AFields.Count = 0 then
    Exit;

  ACtx := TRttiContext.Create;
  try
    AType := ACtx.GetType(Self.ClassType);

    for n1 := 0 to AFields.Count-1 do
      for AProp in AType.GetProperties do
      begin
        if AProp.Visibility in [mvPublished, mvPublic] then
        begin
          for AAttr in AProp.GetAttributes do
          begin
            if AAttr is ColumnAttribute then
            begin
              if AFields.Fields[n1].FieldName = ColumnAttribute(AAttr).ColumnName then
              begin
                AProp.SetValue(Self, TValue.From(AFields.Fields[n1].Value));
                Break;
              end;
            end;
          end;
        end;
      end;
  finally
    ACtx.Free;
  end;
end;

constructor OneToOne.Create(const AFilterPropertyName: string; const AValuePropertyName: string);
begin
  FFilterPropertyName := AFilterPropertyName;
  FValuePropertyName := AValuePropertyName;
end;

constructor OneToMany.Create(const AFilterPropertyName: string; const AValuePropertyName: string);
begin
  FFilterPropertyName := AFilterPropertyName;
  FValuePropertyName := AValuePropertyName;
end;

end.
